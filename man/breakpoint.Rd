% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lmbreak.R
\name{lmbreak}
\alias{lmbreak}
\title{Fit Breakpoint model}
\usage{
lmbreak(
  formula,
  data,
  pattern = NULL,
  start = NULL,
  range = NULL,
  se = FALSE,
  control = NULL,
  trace = FALSE,
  digits = NULL
)
}
\arguments{
\item{formula}{a formula where the breakpoint variable appears on the right hand side
with an argument pattern specifying the number of breakpoints and possible constrains. See the section details.}

\item{data}{[data.frame] dataset}

\item{pattern}{[character or character vector] alternative way to specify the pattern.}

\item{start}{[numeric vector] starting values when estimating the breakpoints.}

\item{range}{[numeric vector of length 2] minimum and maximum outcome value at the breakpoints.}

\item{se}{[logical] should the uncertainty about the breakpoint position be quantified (EXPERIMENTAL).}

\item{control}{[list] parameters to be passed to the optimizer (n.iter,tol,enforce.continuity,optimize.step).
See the section details of \code{\link{lmbreak.options}}.}

\item{trace}{[0,1,2] trace the execution of the function.}

\item{digits}{[integer] how to round values that are displayed in the terminal.}
}
\description{
Fit a linear regression with breakpoints.
}
\details{
\strong{formula}: \code{Y~bp(X, pattern = "111")} indicates a two breakpoints model without constrains (one intercept and three slopes).
\code{Y~bp(X, pattern = "101")} indicates a two breakpoints model with a plateau (one intercept and two slopes).
It can also contain an additional argument to specify where to initalize the breakpoint via a numeric vector: \code{Y~bp(X, pattern = "101", c(1,2))}.

By default initial values for the breakpoints are obtained fitting a spline model and using points where the first derivative of the spline changes sign.
If not enought points are found, quantiles of the response value (Y) are used instead.
}
\examples{

####  simulate data ####
set.seed(10)
df1 <- simBreak(c(1, 100), breakpoint = c(0,1,3,4), slope = c(1,0,-1), sigma = 0.05)

#### fit breakpoint regression ####
## broken line
e.lmbreak111 <- lmbreak(Y ~ bp(X, "111"), data = df1)
plot(e.lmbreak111)
summary(e.lmbreak111)
coef(e.lmbreak111, type = "breakpoint")
coef(e.lmbreak111, type = "slope")
coef(e.lmbreak111, type = "intercept")
coef(e.lmbreak111, type = "duration")
model.tables(e.lmbreak111)

grid111 <- data.frame(tester = "(0,0.5]", X = coef(e.lmbreak111, "breakpoint.range"))
predict(e.lmbreak111, newdata = grid111)

## broken line with plateau
e.lmbreak101 <- lmbreak(Y ~ bp(X, "101"), data = df1)
plot(e.lmbreak101)
summary(e.lmbreak101)
model.tables(e.lmbreak101)

## broken line with plateau and no intercept
e0.lmbreak101 <- lmbreak(Y ~ 0 + bp(X, "101"), data = df1)
plot(e0.lmbreak101, xlim = c(0,4))
summary(e0.lmbreak101)
model.tables(e0.lmbreak101)

#### handle covariates ####
set.seed(10)
df2 <- df1
df2$tester <- cut(df1$X,c(0,0.5,2,4))
df2$Y <- df1$Y + as.numeric(df2$tester) + rnorm(NROW(df1), sd = 0.05)

eCov.lmbreak101 <- lmbreak(Y ~ tester + bp(X, "101"), data = df2, start = c(1.03474573, 2.91979538))
summary(eCov.lmbreak101)
plot(eCov.lmbreak101)

summary(eCov.lmbreak101, continuity = FALSE)
plot(eCov.lmbreak101, continuity = FALSE)

gridCov101 <- data.frame(tester = "(0,0.5]",
                         X = coef(eCov.lmbreak101, "breakpoint.range"))
predict(eCov.lmbreak101, newdata = gridCov101)
predict(eCov.lmbreak101, newdata = gridCov101, continuity = FALSE, extrapolate = TRUE)
}
\references{
Muggeo, V. M. R. Estimating regression models with unknown break-points.
Statistics in medicine 2003; 22:3055-3071.
}
\seealso{
\code{\link{coef.lmbreak}} for extracting the estimated model parameters. \cr
\code{\link{mlmbreak}} for fitting the breakpoint model over multiple clusters of data. \cr
\code{\link{model.tables.lmbreak}} for extracting the breakpoints, slopes, intercept, and duration. \cr
\code{\link{plot.lmbreak}} for a graphical display of the fitted breakpoint model. \cr
}
\keyword{models}
